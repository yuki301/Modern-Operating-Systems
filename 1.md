**1-1 操纵系统的两大主要作用是什么？**

向应用软件提供基本抽象（自顶向下看），为用户提供拓展的机器；作为资源管理者统筹复杂硬件系统的各个部分（自底向上看）。

**1-2 在1.4节中描述了9种不同类型的操作系统，列举每种操作系统的应用（每种操作系统一种应用）。**

（1）大型机操纵系统：银行业务；

（2）服务器操作系统：提供Web网页服务；

（3）多处理器操作系统：运行适配多核处理器的游戏；

（4）个人计算机操作系统：办公软件；

（5）掌上计算机操作系统：社交软件；

（6）嵌入式操作系统：微波炉操控；

（7）传感器节点操作系统：气象信息收集；

（8）实时操作系统：工厂流水线；

（9）智能卡操作系统：学校饭卡；

**1-3 分时系统和多道程序系统的区别是什么？**

分时系统是多道程序设计系统的一个变体，所有分时系统都是多道程序设计系统，但并不是所有多道程序设计系统都是分时系统。多道程序系统在一个作业等待时，让另一个作业使用CPU，最大效率地使用CPU。分时系统能让多个用户使用自己的终端同时访问计算机。

**1-4 为了使用高速缓存，主存被划分为若干cache行，通常每行长32或64字节。每次缓存一整个cache行。每次缓存一整行而不是一个字节或者一个字，这样做的优点是什么？**

实证证据显示，内存访问表现出引用局部性原理，如果读取一个位置，则很可能接下来会访问附近的位置，尤其是下一个内存位置。因此，通过缓存整个缓存行，下一个缓存命中的概率增加。此外，现代硬件可以将32或64字节的数据块传送到缓存行中，比逐个读取同样的数据要快得多。

除此之外，选择缓存行可以减少因为缓存未命中而访问主存的概率，提升效率。

**1-5 在早期计算机中，每个字节的读写直接由CPU处理（即没有DMA）。对于多道程序而言这种组织方式有什么含义？**

多道程序设计的主要原因是在等待I/O完成时给CPU一些工作做。如果没有DMA，CPU在执行I/O时将被充分占用（没有等待时间），因此无法从多道程序设计中获益（至少从CPU利用率角度来看）。无论程序进行多少多久的I/O，CPU都将保持100%忙碌，这样程序无法进行另一个工作。当然，这里假设主要的延迟是在等待数据复制。如果I/O由于其他原因变慢（例如，通过串行线到达），CPU依旧可以去完成其他工作（有等待时间）。

**1-6 与访问I/O设备相关的指令通常是特权指令，也就是说，它们能在内核态执行而在用户态不行。说明为什么这些指令是特权指令。**

对I/O设备如打印机的访问通常会对不同用户进行限制，不同用户的权限不同。这些限制是由管理员依据某种策略设置的。防止用户级程序对其干扰需要执行这些策略。

**1-7 系列计算机的思想在20世纪60年代由IBM引入System/360大型机。现在这种思想已经消亡了还是继续活跃着？**

这种概念依然存在。例如Intel的CPU系列，每一种系列拥有不同属性的CPU，但是它们在体系结构上都是兼容的。

**1-8 缓慢采用GUI的一个原因是支持它的硬件的成本（高昂）。为了支持25行85列字符的单色文本屏幕，需要多少视频RAM？对于1024×768像素24位彩色图需要多少视频RAM？在1980年（每KB5美元），这些RAM的成本是多少？现在它的成本是多少？**

25行85列字符的单色文本屏幕需要25×85=2125B=2KB，在1980年需要10美元。1024×768像素24位彩色图需要1024×768×24/8=2304KB，在1980年需要11520美元。现在，这两种大小RAM的价格基本上可以忽略不计。

**1-9 在建立一个操作系统时有几个设计目的，例如资源利用、及时性、健壮性等。请列举两个可能相互矛盾的设计目的。**

兼容性与及时性。新的系统往往要兼容旧系统的程序、接口，这会限制操作系统建造者们在使操作系统更加高效上的努力。

**1-10 内核态和用户态有哪些区别？解释在设计操作系统时存在两种不同模式有什么帮助。**

CPU在内核态中直接与硬件交互，执行指令集中的所有指令。CPU在用户态中只能执行指令集的子集，利用硬件的子集。同时存在两种模式可以让用户程序运行在用户态中，限制其访问关键指令，保护硬件安全。

**1-11 一个255GB大小的磁盘有65536个柱面，每个磁道有255个扇区，每个扇区有512字节。这个磁盘有多少盘片和磁头？假定平均寻道时间为11ms，平均旋转延迟为7ms，读取速率为100MB/s，计算从一个扇区读取400KB需要的平均时间。**

单个盘片一面的存储容量大小为65536×255×512B=7.96875GB，磁头数目为255GB/7.96875GB=32，盘片数目为32/2=16。平均时间=平均寻道时间+平均旋转延迟+平均读取时间。平均读取时间为400KB/100MB/s=4ms。故平均时间为22ms。

**1-12 下面的哪一条指令只能在内核态使用？**

**（a）禁止所有的中断。**

**（b）读日期-时间时钟。**

**（c）设置日期-时间时钟。**

**（d）改变存储器映像。**

（a）、（c）、（d）。

**1-13 考虑一个有两个CPU的系统，并且每一个CPU有两个线程（超线程）。假设有三个程序P0、P1、P2，分别以运行时间5ms、10ms、20ms开始。运行这些程序需要多少时间？假设这三个程序都是100%限于CPU，在运行时无阻塞，并且一旦设定就不改变CPU。**

根据CPU的调用情况不同，结果可能为20ms、25ms或30ms。

**1-14 一台计算机有一个四级流水线，每一级都花费相同的时间执行其工作，即1ns。这台机器每秒可以执行多少条指令？**

1s/1ns=1000000000（10亿）。执行指令的数量和流水线的级数关系不大。

**1-15 一台计算机系统有高速缓存、内存（RAM）以及磁盘，操作系统用虚拟内存。读取缓存中的一个词需要1ns，RAM需要10ns，磁盘需要10ms。如果缓存命中率时95%，内存是99%（缓存失效时），读取一个词的平均时间是多少？**

0.95×1ns+0.05×0.99×10ns+0.05×0.01×10ms=5001.445ns。

**1-16 在用户程序进行一个系统调用，以读写磁盘文件时，该程序提供指示说明了所需要的文件、一个指向数据缓冲区的指针以及计数。然后，控制权转给操作系统，它调用相关的驱动程序。假设驱动程序启动磁盘并且直到中断发生才终止。在从磁盘读的情况下，很明显，调用者会被阻塞（因为文件中没有数据）。在向磁盘写时会发生什么情况？需要调用者阻塞一直等到磁盘传送完成为止吗？**

可能需要。如果调用者在返回之后立即覆盖需要写入的数据，那么当写操作发生时，就会写入错误的数据。如果驱动程序在返回之前先将数据复制到私有缓冲区中，那么调用者可以立即继续执行。另一种可能性是允许调用者继续执行，并在缓冲区可被重用时给予信号，但这样做很复杂且容易出错。

**1-17 什么是陷阱指令？在操纵系统中解释它的用途。**

陷阱指令使得CPU执行模式从用户态进入内核态。这个指令在操作系统中使得用户程序可以调用内核中的函数。

**1-18 在分时系统中为什么需要进程表？在只有一个进程存在的个人计算系统中，该进程控制整个机器直到进程结束，这种机器也需要进程表吗？**

分时系统需要运行和切换不同的进程，进程表就用于存储当前被挂起的进程（就绪或阻塞）的状态。在只有一个进程存在的个人计算机系统中，进程表也有存在的必要，操作系统需要记录该进程的信息。

**1-19 说明有没有理由在一个非空的目录中安装一个文件系统。如果要这样做，如何做？**

可能有。可以将非空目录中的文件先复制到别的目录下，再安装文件系统。

**1-20 对于下列系统调用，给出引起失败的条件：fork、exec以及unlink。**

进程表没有空余进程项、没有内存或交换空间剩余，fork可能失败；

给定的文件名不存在、给定文件不是有效的可执行文件，exec可能失败；

取消链接的文件不存在、进程无权限，unlink可能失败。

**1-21 下列资源能使用哪种多路复用（时间、空间或者两者皆可）：CPU，内存，磁盘，网卡，打印机，键盘以及显示器？**

时间复用：CPU、网卡、打印机、键盘；

空间复用：内存、磁盘；

时间复用和空间复用：显示器。

**1-22 在**

**count=write(fd,buffer,nbytes);**

**调用中，是否能将函数返回值传递给count变量而不是nbyte变量？如果能，为什么？**

可以。如果函数正确执行将返回实际写入的字节数（可能小于nbyte）。如果失败将返回-1。

**1-23 有一个文件，其文件描述符是fd，内含下列字节序列：3，1，4，1，5，9，2，6，5，3，5。有如下系统调用：**

**lseek(fd,3,SEEK_SET);**

**read(fd,&buffer,4);**

**其中lseek调用寻找文件中的字节3。在读操作完成之后，buffer中的内容是什么？**

lseek系统调用用来设置文件描述符 fd 指向的文件的位置。lseek(fd, 3, SEEK_SET); 表示将文件的位置设置为距离文件开头 3 个字节的位置。即指向第二个1。read系统调用从文件的当前位置开始读取数据。调用 read(fd, &buffer, 4);会从文件中读取 4 个字节，并将它们存储到buffer中。所以最终buffer中的内容是1，5，9，2。

**1-24 假设一个10MB的文件保存在磁盘同一磁道（磁道号为50）的连续扇区中。磁盘的磁臂此时位于第100号磁道。想要从磁盘上找回这个文件，需要多长时间？假设磁臂从一个柱面移动到下一个柱面需要1ms，保存文件的开始部分的扇区旋转到磁头下需要5ms，并且读取速率是200MB/s。**

1ms×（100-50）+5ms+10MB/200MB/s=105ms。

**1-25 块特殊文件和字符特殊文件的基本差别是什么？**

块特殊文件由块组成，支持随机访问，一次可以访问一整个块。通常情况下，字符特殊文件只能顺序读取。

**1-26 在图1-17的例子中库调用称为read，而系统调用自身称为read。这两者都有相同的名字是正常的吗？如果不是，哪一个更重要？**

是正常的。库函数的名字用于在程序中调用，库函数封装了系统调用，这样通过库函数就可以在程序中进行系统调用了。系统调用实际上没有名字（除去文档意义上的）。

**1-27 现代操作系统将进程的地址空间从机器物理内存中分离出来。列举这种设计的两个好处。**

每个进程可以拥有自己的虚拟地址空间，不会受到其它进程的影响；可以使用硬盘空间作为临时内存。

**1-28 对程序员而言，系统调用就像对其他库过程的调用一样。有无必要让程序员了解哪一个库过程导致了系统调用？在什么情形下，为什么？**

在性能优化等情形下有必要让程序员知道。程序的工作在没有系统调用的情况下将完成得更快，系统调用涉及到用户空间和内核空间的上下文切换，将带来性能开销，程序员如果了解这些调用，可以针对性地做出优化。

**1-29 图1-23说明有一批UNIX系统调用没有与之等价的Win32 API。对于所列出的每一个没有Win32等价的调用，若程序员要把一个UNIX程序转换到Windows下运行，会有什么后果？**

link：一个Win32 程序不能通过替代名称引用文件，也不能在多个目录中看到同个文件。此外，尝试创建链接是方便的测试文件并创建文件锁的方法。

mount 和 umount：一个Windows 程序不能对标准路径名作出假设，因为在具有多个磁盘驱动器的系统上，路径中的驱动器名称部分可能有所不同。

chmod：Windows 使用访问控制列表。

Kill：Windows 程序员无法终止不合作的错误程序。

**1-30 可移植的操作系统是从一个系统体系结构移动到另一个系统体系结构而不需要任何修改的操作系统。请解释为什么建立一个完全可移植性的操作系统是不可行的。描述一下在设计一个高度可移植的操作系统时你设计的两个高级层是什么样的。**

不同体系的硬件拥有不同的指令集，不同的硬件还会有带来CPU字长、总线架构等方面的不同，这些硬件上的差异使得构建一个完全可移植的操作系统是不可能的。两个高级层次是机器相关层和机器无关层。机器相关层处理硬件的具体细节，为每种架构单独实现，提供了一个统一的接口，用于构建机器无关层。机器无关层只要实现一次。

**1-31 请解释在建立基于微内核的操作系统时策略与机制分离带来的好处。**

策略与机制分离允许操作系统设计者在内核中只实现一小部分原语，且这些原语不依赖特定的策略，可以使用这些原语在用户级别实现更复杂的机制和策略。这便于了操作系统内核的移植。同时添加、更新或替换策略变得容易，而不会影响到内核的其他部分，操作系统可扩展性增强，更加模块化。如果某个服务崩溃或出现错误，它不会影响到内核的稳定性，因为内核与这些服务是隔离的，操作系统的稳定性得到了增强。这还便于权限管理和访问控制，增强了系统安全性。

**1-32 虚拟机由于很多因素而十分流行，然而他们也有一些缺点，给出一个缺点。**

虚拟机增加了硬件开销，带来了性能损耗。

**1-33 下面是单位转换的练习：**

**（a）一微年是多少秒？**

**（b）微米常称为micron。那么meigamicro是多长？**

**（c）1PB存储器中有多少字节？**

**（d）地球的质量是6000 yottagram，换算成kilogram是多少？**

一微年=1/1000000×365×24×60×60s=31.536s。meigamicro=1000000×1um=1m。1PB=1Byte×1024×1024×1024×1024×1024=2^50Byte。6000 yottagram=6000×10^24 gram=6000×10^21 kilogram。

**1-34 写一个和图1-19类似的shell，但是包含足够的实际可工作的代码，这样测试它。还可以添加某些功能，如输入输出重定向、管道以及后台作业等。**

以下是一个在Windows上可工作的shell模拟程序，可以创建子进程（不能执行命令，无其余功能）。

对于部分编译器，CreateProcessA的第一个参数应当设置为编译后可执行文件的路径，否则无法正常运行。

```c
#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <windows.h>

#define CMD_MAX_LEN 1024 //命令行最大字符数为1023，末尾为NULL
#define CMD_MAX_ARGS 64 //参数数量最大为63，末尾为NULL

void type_prompt() 
{
    printf("myshell> ");
}

void read_command(char* command, char* parameters[]) 
{
    char input[CMD_MAX_LEN];
    fgets(input, CMD_MAX_LEN, stdin);
    input[strcspn(input, "\n")] = '\0'; //将换行符替换为'\0'

    //根据空格分割获取参数
    char* token = strtok(input, " ");
    int i = 0;
    while (token != NULL) 
    {
        parameters[i++] = token;
        token = strtok(NULL, " ");
    }
    parameters[i] = NULL; 
}

int main() 
{
    char* parameters[CMD_MAX_ARGS];
    PROCESS_INFORMATION processInfo; //存储用于创建新进程的信息的结构
    ZeroMemory(&processInfo, sizeof(processInfo)); //初始化结构体内存为0
    STARTUPINFOA startupInfo; //用于指定新进程的主窗口的外观和如何启动新进程
    ZeroMemory(&startupInfo, sizeof(startupInfo));
    startupInfo.cb = sizeof(startupInfo); 
    //将结构体大小赋给结构体成员，创建进程函数可以正确读取结构体

    while (1) 
    {
        type_prompt();
        read_command(NULL, parameters);

        //退出指令
        if (strcmp(parameters[0], "exit") == 0) 
        {
            break;
        }

        if (!CreateProcessA(
            NULL, //使用第二个参数（命令行）启动进程
            parameters[0],
            NULL, //不继承父进程的句柄
            NULL, //不继承父进程的线程句柄
            FALSE, //新进程不会继承父进程的句柄
            0, //不使用特殊创建方式
            NULL, //新进程使用父进程的环境变量
            NULL, //新进程使用父进程的当前目录
            &startupInfo,
            &processInfo
        )) 
        {
            printf("CreateProcess failed (%d).\n", GetLastError());//获取并显示错误信息
            continue;
        }

        //等待进程结束
        WaitForSingleObject(processInfo.hProcess, INFINITE);

        //关闭进程和线程
        CloseHandle(processInfo.hProcess);
        CloseHandle(processInfo.hThread);
    }

    return 0;
}
```

**1-35 如果你有一个个人UNIX类操作系统（Linux、MINIX/3、FreeBSD等），可以安全地崩溃再启动，请写一个试图创建无限制数量子进程的shelll脚本并观察所发生的事。在运行实验前，通过shell键入sync，在磁盘上备好文件缓冲区以避免破坏文件系统。注意：在没有得到系统管理员的允许之前，不要再分时系统上进行这一尝试。其后果将会立即出现，尝试者可能会被抓住并受到惩罚。**

试图创建无限制数量子进程的shell脚本如下。在分配了4GB内存、2个CPU、20GB硬盘的虚拟机上的Ubuntu23.10上运行该脚本，可观察到其中一个CPU的占用率快速上升，最终达到100%，其余性能指标未见明显波动。

```
#!/bin/bash

# 清除所有已经存在的子进程
trap 'kill $(jobs -p)' EXIT

# 同步文件系统缓冲区
sync

# 开始创建无限数量的子进程
while true; do
    # 创建子进程
    fork() {
        bash -c fork &
    }
    fork

done
```

**1-36 用一个类似于UNIX od的工具考察并尝试解释UNIX类系统或Windows的目录。提示：如何进行取决于OS允许做什么。一个有益的技巧是在软盘上创建一个目录，其中包含一个操作系统，然后使用另一个允许进行此类访问的不同的操作系统读取盘上的原始数据。**

可以使用如WinHex等程序考察Windows中的文件。
